<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Secure Auth Demo</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 40px;
    }
    form {
      margin-bottom: 20px;
    }
    input {
      margin: 5px 0;
      display: block;
    }
    #wiki-tutorial {
      margin-top: 40px;
      padding: 20px;
      border: 1px solid #ccc;
      background: #f9f9f9;
    }
    #wiki-tutorial h2 {
      margin-top: 0;
    }
    #wiki-tutorial code {
      background: #eef;
      padding: 2px 4px;
      display: inline-block;
    }
  </style>
</head>
<body>
  <h1>Secure Authentication Demonstration</h1>

  <h2>Register</h2>
  <form action="/register" method="POST">
    <label for="reg_username">Username:</label>
    <input type="text" name="username" id="reg_username" required>
    <label for="reg_password">Password:</label>
    <input type="password" name="password" id="reg_password" required>
    <button type="submit">Register</button>
  </form>

  <h2>Login</h2>
  <form action="/login" method="POST">
    <label for="log_username">Username:</label>
    <input type="text" name="username" id="log_username" required>
    <label for="log_password">Password:</label>
    <input type="password" name="password" id="log_password" required>
    <button type="submit">Login</button>
  </form>

  <p>After logging in, you'll be able to view a protected page!</p>

  <!-- SMALL WIKI / TUTORIAL SECTION -->
  <div id="wiki-tutorial">
    <h2>How We Implemented Secure Authentication</h2>
    <p>
      This tutorial explains how you can implement a secure user authentication feature that ensures
      passwords are <strong>never sent or stored in plain text</strong>. Below are the core steps:
    </p>

    <h3>1. Use HTTPS</h3>
    <p>
      By configuring an <strong>HTTPS</strong> server (e.g., with a self-signed certificate in development
      or a trusted certificate in production), all communication between the client and server is
      <strong>encrypted</strong>. This prevents passwords from being read in transit.
    </p>

    <h3>2. Hash Passwords with Bcrypt (or Argon2)</h3>
    <p>
      In our <code>server.js</code>, we use a library like <code>bcrypt</code> to
      securely hash (and salt) the user's password before saving it. For example:
    </p>
    <pre><code>
// Example registration route
app.post('/register', async (req, res) => {
  const { username, password } = req.body;
  
  // Generate a salted hash
  const passwordHash = await bcrypt.hash(password, 10);
  
  // Store the hashed password in our "database"
  users.push({ username, passwordHash });
  res.send('User registered successfully!');
});
    </code></pre>
    <p>
      The important point is that you <strong>never</strong> store or log the raw password; you only keep
      the hashed version. If an attacker somehow accesses the database, they won’t directly get
      the user’s actual password.
    </p>

    <h3>3. Verify Passwords on Login</h3>
    <p>
      When a user logs in, you compare their typed-in password (hashed again behind the scenes) with
      the stored hash:
    </p>
    <pre><code>
// Example login route
app.post('/login', async (req, res) => {
  const { username, password } = req.body;
  const user = users.find(u => u.username === username);
  if (!user) return res.send('Invalid username or password');

  // Compare typed-in password with stored hash
  const isMatch = await bcrypt.compare(password, user.passwordHash);
  if (!isMatch) return res.send('Invalid username or password');

  // If successful, create a session or token
  req.session.user = { username };
  res.send(`Welcome, ${username}!`);
});
    </code></pre>

    <h3>4. Session Management</h3>
    <p>
      We used <code>express-session</code> to create and manage user sessions, storing a session ID
      in a cookie. This means the user doesn’t have to re-enter their password for each request.
      The session data is stored server-side, <strong>never</strong> exposing the raw password.
    </p>

    <h3>5. Summary of Best Practices</h3>
    <ul>
      <li>Use <strong>HTTPS</strong> to encrypt data in transit.</li>
      <li>Use a proper hashing function (<strong>bcrypt</strong>, <strong>argon2</strong>) with salting.</li>
      <li>Store only <strong>hashed</strong> passwords in your database—never plaintext.</li>
      <li>Implement <strong>sessions or tokens</strong> so users don’t need to keep sending credentials.</li>
      <li>Keep secrets (session secrets, DB passwords) in environment variables.</li>
      <li>Consider <strong>rate limiting</strong> on login endpoints to prevent brute force attacks.</li>
    </ul>

    <p>
      By following these steps, another developer can easily replicate this setup. They would just need:
      <br>- A Node.js server (using Express)
      <br>- The <code>bcrypt</code> (or argon2) library
      <br>- A session management library (e.g. <code>express-session</code>)
      <br>- A client-side form for <strong>Register</strong> and <strong>Login</strong>.
    </p>

    <p><em>This mini wiki/tutorial should help anyone integrate secure authentication into their own project.</em></p>
  </div>
</body>
</html>